/*
 * graph.c --
 *
 * Author -- Pedro Aguilar <paguilar@junkerhq.net>
 *
 * Copyright (c) 2004 - 2006 Pedro Aguilar
 *
 * Description: Create a graph that contains 3 single-linked lists.
 *    For a deep explanation of the CLI parser see docs.
 *    The CLI can have several modes, according to functional levels, some of them may need 
 *    authorization.
 *    List 1: The first list is composed of modes, each node in the list represent a mode. 
 *    Eg. the first node (level) could be for basic commands, second node for priviledged (root)
 *    commands, third mode for interfaces configuration, and so on.
 *    List 2: Since each mode can have several commands, each node of the mode list has a list of 
 *    commands. Eg. For the third mode typical commands would be 'ifconfig', 'route'...
 *    List 3: Since each command can have several arguments, each node of the command list has a
 *    list of arguments. Eg. The cmd 'ifconfig' needs as args the ip address, netmask, ...
 *
 *    Input: These functions are called from the parser generated by Bison and receive as input 
 *    the global ptrs to each one of the lists (the global ptrs are inside a global struct for
 *    ease of handling) and a given token.
 *
 *    Output: All the functions called from the parser return the global struct that
 *    contains the ptrs to each one of the lists. The rest of the functions return an int or 
 *    the same global struct.
 *    If there is an error the global variable parserr is set to 1 and when yyparse() returns
 *    the error is printed.
 *
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/*****************************
 * INCLUDES
 *****************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "graph.h"
#include "misc.h"

/*****************************
 * DATA TYPES
 *****************************/

CLIMatrix	matrix;
extern int	parserr;

/*****************************
 * FUNCTION IMPLEMENTATION
 *****************************/

/***********************
 * Create the graph at start-up
 ***********************/

/*
 * Description: Init the global ptrs 
 */
static SList graph_new() {
    return slist_new();
}


/*
 * Description: Create and init the main struct that has the global ptrs 
 *		to the mode, command and argument lists
 */
CLIMatrix graph_matrix_init() {
    CLIMatrix	ptr = NULL;

    if ((ptr = (CLIMatrix)xmalloc(sizeof(struct CLIMatrix_st), 1)) == NULL) {
        TRS_ERR("Could not create graph main pointers!");
	parserr = 1;
        return (CLIMatrix)NULL;
    }

    ptr->graph = ptr->mode = ptr->cmd = ptr->arg = graph_new();
    return ptr;
}


/*
 * Description: Reset global ptrs
 */
void graph_reset_ptrs() {
    CLIModeNode mode;
    CLICmdNode  cmd;

    matrix->mode = matrix->graph;
    mode = (CLIModeNode)matrix->mode->data;
    matrix->cmd = (SList)mode->cmd_list;
    cmd = (CLICmdNode)matrix->cmd->data;
    matrix->arg = (SList)cmd->arg_list;
}


/***********************
 * MODE functions
 ***********************/

/*
 * Description: The given mode name exists?
 */
static int graph_mode_exist(char *mode_name) {
    SList	list = NULL;
    CLIModeNode mode_node = NULL;

    list = matrix->graph;
    while (list) {
	mode_node = (CLIModeNode)list->data;
	if (!strcmp(mode_node->name, mode_name)) {
	    debug_rhal_printf("--- MODE ---\nMode id %d (%s) exists\n", 
                mode_node->id, mode_node->name);
	    /* Move global ptr 'mode' to the current mode node */
	    matrix->mode = list;
	    return 1;
	}
	list = list->next;
    }

    return 0;
}


/*
 * Description: Create a mode node
 */
static CLIMatrix graph_mode_insert_struct(char *mode_name) {
    CLIModeNode	 ptr = NULL,
                 mode_node = NULL;
    CLIAvailNode avail_node = NULL;
    SList        graph_node = NULL;

    /* Create the elements of the mode node */
    if ((mode_node = (CLIModeNode)xmalloc(sizeof(struct CLIModeNode_st), 1)) == NULL) {
	TRS_ERR("Could not allocate memory for mode struct!");
	parserr = 1;
	return matrix;
    }

    if ((avail_node = (CLIAvailNode)xmalloc(sizeof(struct CLIAvailNode_st), 1)) == NULL) {
	TRS_ERR("Could not allocate memory for mode avail!");
	parserr = 1;
        return matrix;
    }

    /* Init the elements of the avail node */
    avail_node->mode_id = -1;
    avail_node->cmd_id = -1;

    /* Init the elements of the mode node */
    mode_node->id = slist_count(matrix->graph);
    mode_node->name = strdup(mode_name);
    mode_node->prompt = (char *)NULL;
    mode_node->cmd_count = 0;
    mode_node->parent = -1;
    mode_node->cmd_list = (SList)NULL;
    mode_node->avail = slist_new();

    /* Add the avail node to the mode node */
    if ((mode_node->avail = slist_append(mode_node->avail, (void *)avail_node)) == NULL) {
        TRS_ERR("Could not append avail node to SList");
	parserr = 1;
        return matrix;
    }

    /* Add the mode node to the graph */
    if ((matrix->graph = slist_append(matrix->graph, (void *)mode_node)) == NULL) {
	TRS_ERR("Could not append mode node to SList");
	parserr = 1;
	return matrix;
    }

    /* Point the global mode ptr to this mode node */
    graph_node = matrix->graph;
    while (graph_node) {
	ptr = (CLIModeNode)graph_node->data;
        if (ptr->id == mode_node->id) {
	    matrix->mode = graph_node;
	    debug_rhal_printf("--- MODE ---\nid = '%d', name: '%s'\n", ptr->id, ptr->name);
	    break;
	}
        graph_node = graph_node->next;
    }

    return matrix;
}


/*
 * Description: Create a new mode
 */
CLIMatrix graph_mode_insert(char *mode_name) {
    if (!graph_mode_exist(mode_name)) {
        if ((matrix = graph_mode_insert_struct(mode_name)) == NULL) {
	    TRS_ERR("Could not create mode struct!");
	    parserr = 1;
	    return matrix;
	}
    }
    return matrix;
}


/*
 * Description: Create a new mode given that a cmd of another existent mode
 *     wants to be available to a not-yet created mode
 */
static int graph_mode_insert_from_avail_cmd(char *mode_name, short int mode_id, short int cmd_id) {
    CLIModeNode	 mode_node = NULL;
    CLIAvailNode avail_node = NULL;

    debug_rhal_printf("\n\t\t\t--- IMPLICIT MODE CREATION ---\n\t\t\tCreating mode '%s' from available command id %d\n", 
        mode_name, cmd_id);
    /* Create and init the elements of the mode node */
    if ((mode_node = (CLIModeNode)xmalloc(sizeof(struct CLIModeNode_st), 1)) == NULL) {
	TRS_ERR("Could not allocate memory for mode struct!");
	parserr = 1;
	return 0;
    }
    mode_node->id = slist_count(matrix->graph);
    mode_node->name = strdup(mode_name);
    mode_node->prompt = (char *)NULL;
    mode_node->cmd_count = 0;
    mode_node->parent = -1;
    mode_node->cmd_list = (SList)NULL;
    mode_node->avail = slist_new();

    /* Create and init the tail avail node */
    if ((avail_node = (CLIAvailNode)xmalloc(sizeof(struct CLIAvailNode_st), 1)) == NULL) {
	TRS_ERR("Could not allocate memory for mode avail!");
	parserr = 1;
        return 0;
    }
    avail_node->mode_id = -1;
    avail_node->cmd_id = -1;

    /* Add the tail avail node to the mode node */
    if ((mode_node->avail = slist_append(mode_node->avail, (void *)avail_node)) == NULL) {
        TRS_ERR("Could not append avail node to SList");
	parserr = 1;
        return 0;
    }

    /* Add the mode node to the graph */
    if ((matrix->graph = slist_append(matrix->graph, (void *)mode_node)) == NULL) {
	TRS_ERR("Could not append mode node to SList");
	parserr = 1;
	return 0;
    }

    if (!graph_mode_insert_avail(mode_node, mode_id, cmd_id)) {
	TRS_ERR("Could not insert avail command to new mode");
        return 0;
    }

    return 1;
}


/*
 * Description: The given mode id exists?
 */
int graph_mode_id_exist(short int mode_id) {
    SList	graph_list = NULL;
    CLIModeNode mode_node = NULL;

    graph_list = matrix->graph;
    while (graph_list) {
	mode_node = (CLIModeNode)graph_list->data;
        if (mode_node->id == mode_id) {
	    debug_rhal_printf("--- MODE ---\nMode id '%d' (%s) exists\n", mode_node->id, mode_node->name);
	    /* Move global ptr 'mode' to the current mode node */
	    matrix->mode = graph_list;
	    return 1;
	}
	graph_list = graph_list->next;
    }

    return 0;
}


/*
 * Description: Gets the mode prompt. If the mode is defined is several files with
 *     different prompts, only the first one will be used.
 */
CLIMatrix graph_mode_insert_prompt(char *prompt) {
    CLIModeNode 	ptr = NULL;

    if (!matrix->mode) {
	TRS_ERR("Could not find mode!");
	parserr = 1;
	return matrix;
    }

    ptr = (CLIModeNode)matrix->mode->data;
    if (ptr->prompt) {
	debug_rhal_printf("\t--- PROMPT ---\n\tThis mode already has a prompt: '%s'\n", ptr->prompt);
	return matrix;
    }

    if ((ptr->prompt = (char *)xmalloc(sizeof(char), strlen(prompt) - 1)) == NULL) {
        parserr = 1;
        return matrix;
    }   
    reset_buff(ptr->prompt, strlen(prompt) - 1);
    /* Removed the unwanted " at the start and end of the 'prompt' string */
    strncpy(ptr->prompt, prompt + 1, strlen(prompt) - 2);

/*    ptr->prompt = strndup(prompt + 1, strlen(prompt) - 2); */
    
    debug_rhal_printf("\t--- PROMPT ---\n\tPrompt: '%s'\n", ptr->prompt);

    return matrix;
}


/*
 * Description: Inside the given mode, the command cmd_id from 
 *     mode mode_id can be executed. This is useful for cmds 
 *     like show and exit that should be available at all levels(modes).
 */
int graph_mode_insert_avail(CLIModeNode mode, int mode_id, int cmd_id) {
    CLIAvailNode 	avail_node = NULL,
			ptr = NULL;
    SList		avail_list = NULL;

    avail_list = mode->avail;

    if ((avail_node = (CLIAvailNode)xmalloc(sizeof(struct CLIAvailNode_st), 1)) == NULL) {
        TRS_ERR("Could not allocate memory for avail struct!");
	parserr = 1;
        return 0;
    }

    avail_node->mode_id = -1;
    avail_node->cmd_id = -1;

    if ((avail_list = slist_append(avail_list, (void *)avail_node)) == NULL) {
        TRS_ERR("Could not append avail node to SList");
	parserr = 1;
        return 0;
    }

    if (avail_list->next == NULL) {
	TRS_ERR("Just one element in avail list; should be at least two");
	parserr = 1;
	return 0;
    }

    while (avail_list->next) {
	if (avail_list->next->next == NULL) {
	    ptr = (CLIAvailNode)avail_list->data;
	    ptr->mode_id = mode_id;
	    ptr->cmd_id = cmd_id;
	    break;
	}
	avail_list = avail_list->next;
    }

#ifdef DEBUG_RHAL
    avail_list = mode->avail;
    while (avail_list) {
	ptr = (CLIAvailNode)avail_list->data;
	if (ptr->mode_id < 0  || ptr->cmd_id < 0)
	    printf("\t\t\tExporting command id: %d from mode id: %d. (End of list)\n", 
                ptr->cmd_id, ptr->mode_id);
	else
	    printf("\t\t\tExporting command id %d from mode id %d to mode %s\n", 
                ptr->cmd_id, ptr->mode_id, mode->name);
	avail_list = avail_list->next;
    }
#endif

    return 1;
}


/*
 * Description: Count the number of cmds from other modes that are 
 *     already available to this mode
 */
int graph_mode_count_avail(CLIAvailNode avail) {
    CLIAvailNode	ptr = NULL;
    int			i = 1;

    for (ptr = avail; ptr->mode_id != -1; ptr++, i++);

    return i;
}


/*
 * Description: Count the number of cmds that each mode has
 *     This function is only used for debugging
 */
int graph_mode_cmd_count(SList graph) {
    CLIModeNode mode_node;
    SList       graph_list,
                cmd_list;
    int         total = 0,
                cmd_cnt;

    graph_list = graph;
    while (graph_list) {
        mode_node = (CLIModeNode)graph_list->data;
        cmd_list = (SList)mode_node->cmd_list;
        cmd_cnt = 0;
        while (cmd_list) {
            cmd_cnt++;
            cmd_list = cmd_list->next;
        }
        mode_node->cmd_count = cmd_cnt;
        debug_rhal_printf("Mode '%s' with id %d has %d cmds\n", 
            mode_node->name, mode_node->id, mode_node->cmd_count);
        total += cmd_cnt;
        graph_list = graph_list->next;
    }

    return total;
}


/*
 * Description: The given mode id with its cmd id exists?
 */
SList graph_mode_cmd_id_exist(short int mode_id, short int cmd_id) {
    SList	mode_list = NULL,
                cmd_list = NULL;
    CLICmdNode  cmd_node = NULL;
    CLIModeNode mode_node = NULL;

    mode_list = matrix->graph;
    while (mode_list) {
	mode_node = (CLIModeNode)mode_list->data;
/*        printf("Is given mode %d = curr mode %d\n", mode_id, mode_node->id); */
        if (mode_node->id == mode_id) {
            cmd_list = mode_node->cmd_list;
            while (cmd_list) {
                cmd_node = (CLICmdNode)cmd_list->data;
/*                printf("Is given cmd %d = cmd mode %d\n", cmd_id, cmd_node->id); */
                if (cmd_node->id == cmd_id)
                    return cmd_list;
                cmd_list = cmd_list->next;
            }
	}
	mode_list = mode_list->next;
    }

    return NULL;
}

/**
 * Change the mode node in the mode list
 *
 * @param mode_name: the name of the mode to
 *        which we want to change
 *
 * @return 1 if the mode change was successful
 *         0  otherwise
 *
 * @ingroup Mode Handling
 */
int trs_graph_mode_change(char *mode_name) {
    short int   curr_mode_id;
    SList       mode_list;
    CLIModeNode mode_node;

    if (!mode_name)
        return 0;

    mode_node = (CLIModeNode)matrix->mode->data;
    curr_mode_id = mode_node->id;

    if (!graph_mode_exist(mode_name))
        return 0;

    mode_list = matrix->graph;
    while (mode_list) {
        mode_node = (CLIModeNode)mode_list->data;
        debug_rhal_printf("%s == %s?\n", mode_name, mode_node->name);
        if (!strcmp(mode_name, mode_node->name)) {
            mode_node->parent = curr_mode_id;
            debug_rhal_printf("Parent id: %d\n", mode_node->parent);
            matrix->mode = mode_list;
            return 1;
        }
        mode_list = mode_list->next;
    }

    return 0;
}


/***********************
 * CMD functions
 ***********************/

/*
 * Description: Create a command node
 */
static CLIMatrix graph_cmd_insert_struct(char *cmd_name) {
    CLIModeNode mode_node = NULL;
    CLICmdNode	cmd_node = NULL;
    int		i;
#ifdef DEBUG_RHAL
    CLICmdNode	ptr = NULL;
#endif

    /* Create and init the elements of the cmd node */
    if ((cmd_node = (CLICmdNode)xmalloc(sizeof(struct CLICmdNode_st), 1)) == NULL) {
	TRS_ERR("Could not allocate memory for command struct!");
	parserr = 1;
	return matrix;
    }

    cmd_node->name = strdup(cmd_name);
    cmd_node->func_name = (char *)NULL;
    cmd_node->desc = (char *)NULL;
    cmd_node->arg_list = (SList)NULL;

    /* Add the cmd node to its mode */
    mode_node = (CLIModeNode)matrix->mode->data;
    if ((mode_node->cmd_list = slist_append(mode_node->cmd_list, (void *)cmd_node)) == NULL) {
	TRS_ERR("Could not append command node to SList");
	parserr = 1;
	return matrix;
    }

    /* Point the global cmd ptr to this cmd node */
    matrix->cmd = mode_node->cmd_list;
    cmd_node->id = slist_count(mode_node->cmd_list) - 1;
    for (i = 0; i < cmd_node->id; i++)
	matrix->cmd = matrix->cmd->next;

#ifdef DEBUG_RHAL
    ptr = (CLICmdNode)(matrix->cmd->data);
    printf("\t--- CMD ---\n\tid = %d, name = '%s'\n", ptr->id, ptr->name);
#endif

    return matrix;
}


/*
 * Description: Create a new command
 */
CLIMatrix graph_cmd_insert(char *cmd_name) {
    if (!(matrix->mode)) {
	TRS_ERR("Could not find mode!");
	parserr = 1;
	return matrix;
    }

    if (!graph_cmd_exist(matrix->mode, cmd_name)) {
        if ((matrix = graph_cmd_insert_struct(cmd_name)) == NULL) {
	    TRS_ERR("Could not create command struct!");
	    parserr = 1;
	    return matrix;
	}
    }

    return matrix;
}


/*
 * Description: The given command exists?
 */
int graph_cmd_exist(SList mode, char *cmd_name) {
    SList	list = NULL;
    CLIModeNode	mode_node = NULL;
    CLICmdNode 	cmd_node = NULL;

    mode_node = (CLIModeNode)mode->data;
    list = (SList)mode_node->cmd_list;
    while (list) {
	cmd_node = (CLICmdNode)list->data;
	if (!strcmp(cmd_node->name, cmd_name)) {
	    debug_rhal_printf("Command '%s' already exists\n", mode_node->name);
	    /* Move the global cmd ptr to the current cmd node */
	    matrix->cmd = list;
	    return 1;
	}
	list = list->next;
    }

    return 0;
}


/*
 * Description: Get the function name that will be called when
 *     the current cmd is executed
 */
CLIMatrix graph_cmd_insert_func(char *func_name) {
    CLICmdNode ptr = NULL;

    if (!matrix->cmd) {
        TRS_ERR("Could not find command!");
        parserr = 1;
        return matrix;
    }

    ptr = (CLICmdNode)matrix->cmd->data;
    ptr->func_name = strdup(func_name);

    debug_rhal_printf("\t\t--- FUNC ---\n\t\tFunction linked to this command: %s\n", 
        ptr->func_name);
    return matrix;
};


/*
 * Description: If the command has to be available to other modes, insert its id
 *     and its mode id into the target's available-list mode
 */
CLIMatrix graph_cmd_insert_avail(char *avail) {
    SList	graph_node = NULL;
    CLIModeNode mode_list = NULL;
    CLICmdNode 	cmd_node = NULL;
    char	*avail_ptr = NULL;
    CLIModeNode	mode_curr = NULL;

    if (!matrix->cmd) {
	TRS_ERR("Could not find command!");
	parserr = 1;
	return matrix;
    }

    avail_ptr = strdup(avail);

    graph_node = matrix->graph;
    cmd_node = (CLICmdNode)matrix->cmd->data;
    mode_curr = (CLIModeNode)matrix->mode->data;
    debug_rhal_printf("\t\t--- AVAIL ---\n\t\tThis command will be available to mode: '%s'\n\t\tThis command belongs to mode '%s'\n", 
	avail_ptr, mode_curr->name);

    while (graph_node) {
	mode_list = (CLIModeNode)graph_node->data;
	debug_rhal_printf("\t\tMode that I'm passing in the list: %s\n", mode_list->name);
	/* If the avail mode is equal to any mode except the current one 
         * to which this cmd belongs then add it to the cmd availability 
         * list that belongs to that other mode */
	if (!strcmp(avail_ptr, mode_list->name) && strcmp(avail_ptr, mode_curr->name)) {
	    if (!graph_mode_insert_avail(mode_list, mode_curr->id, cmd_node->id)) {
		TRS_ERR("Could not insert command availability!");
		free(avail_ptr);
		return matrix;
	    }
	    free(avail_ptr);
	    return matrix;
	}
	graph_node = graph_node->next;
    }

    debug_rhal_printf("\t\tEnd of list. Mode \'%s\' not found!\n", avail_ptr);
    /* If the cmd was previously available we print an error 
     * else the mode doesn't exists (this means that we wanted to make this cmd available to
     * a non-existent mode. Thus, create the mode and insert the cmd. This will allow to have
     * modes without cmds, they could only contain cmds that belong to other modes)
     */
    if (!strcmp(avail_ptr, mode_curr->name))
        debug_rhal_printf("\t\tCmd already belongs to mode '%s'", avail_ptr);
    else {
        debug_rhal_printf("\t\tTarget mode '%s' doesn't exist! Creating it...", 
            avail_ptr);

        if (!graph_mode_insert_from_avail_cmd(avail_ptr, mode_curr->id, cmd_node->id))
            TRS_ERR("Could not create mode from command availability!");
    }
    free(avail_ptr);
    return matrix;
}


/***********************
 * ARG functions
 ***********************/

/*
 * Description: Create an argument node
 */
static CLIMatrix graph_arg_insert_struct(char *arg_sid) {
    CLIArgNode 	arg_node = NULL;
    CLICmdNode	cmd_node = NULL;
    int		i;
#ifdef DEBUG_RHAL
    CLIArgNode	ptr = NULL;
#endif

    /* Create the elements of the arg node */
    if ((arg_node = (CLIArgNode)xmalloc(sizeof(struct CLIArgNode_st), 1)) == NULL) {
	TRS_ERR("Could not allocate memory for argument struct!");
	parserr = 1;
	return matrix;
    }

    /* Init the elements of the arg node */
    arg_node->sid = strdup(arg_sid);
    arg_node->name = (char *)NULL; 
    arg_node->value = (char *)NULL; 
    arg_node->prio = (char *)NULL;
    arg_node->desc = (char *)NULL; 
    arg_node->parent = -1;

    /* Add the arg node to its cmd */
    cmd_node = (CLICmdNode)matrix->cmd->data;
    if ((cmd_node->arg_list = slist_append(cmd_node->arg_list, (void *)arg_node)) == NULL) {
	TRS_ERR("Could not append argument node to SList");
	parserr = 1;
        return matrix;
    }

    /* Point the global arg ptr to this arg node and init the arg id */
    matrix->arg = cmd_node->arg_list;
    arg_node->id = slist_count(cmd_node->arg_list) - 1;
    for (i = 0; i < arg_node->id; i++)
	matrix->arg = matrix->arg->next;

#ifdef DEBUG_RHAL
    ptr = (CLIArgNode)(matrix->arg->data);
    printf("\t\t--- ARG ---\n\t\tid = %d, sid = '%s'\n", ptr->id, ptr->sid);
#endif
    return matrix;
}


/*
 * Description: Create a new argument
 */
CLIMatrix graph_arg_insert(char *arg_sid) {
    if (!graph_arg_exist(matrix->cmd, arg_sid)) {
        if ((matrix = graph_arg_insert_struct(arg_sid)) == NULL) {
	    TRS_ERR("Could not create argument struct!");
	    parserr = 1;
	    return matrix;
	}
    }
    return matrix;
}


/*
 * Description: The given argument exists?
 */
int graph_arg_exist(SList cmd, char *arg_sid) {
    SList	list = NULL;
    CLICmdNode	cmd_node = NULL;
    CLIArgNode	arg_node = NULL;

    cmd_node = (CLICmdNode)cmd->data;
    list = (SList)cmd_node->arg_list;
    while (list) {
	arg_node = (CLIArgNode)list->data;
	if (!strcmp(arg_node->sid, arg_sid)) {
	    debug_rhal_printf("\t\tArg %s already exists\n", arg_node->sid);
	    /* Move the global arg ptr to the current arg node */
	    matrix->arg = list;
	    return 1;
	}
	list = list->next;
    }
    return 0;
}


/*
 * Description: Get the arg's name
 */
CLIMatrix graph_arg_insert_name(char *name) {
    CLIArgNode 	ptr = NULL;

    if (!matrix->arg) {
	TRS_ERR("Could not find argument!");
	parserr = 1;
	return matrix;
    }

    ptr = (CLIArgNode)matrix->arg->data;
    if ((ptr->name = (char *)xmalloc(sizeof(char), strlen(name) - 1)) == NULL) {
	parserr = 1;
	return matrix;
    }
    reset_buff(ptr->name, strlen(name) - 1);
    /* Removed the unwanted " at the start and end of the 'name' string */
    strncpy(ptr->name, name + 1, strlen(name) - 2);

    debug_rhal_printf("\t\t\t--- NAME ---\n\t\t\tCmd: %s, Name: %s\n", ptr->sid, ptr->name);
    return matrix;
}


/*
 * Description: Get the arg's value type: integer, string, hex...
 */
CLIMatrix graph_arg_insert_value(char *value) {
    CLIArgNode 	ptr = NULL;

    if (!matrix->arg) {
	TRS_ERR("Could not find argument!");
	parserr = 1;
	return matrix;
    }

    ptr = (CLIArgNode)matrix->arg->data;
    ptr->value = strdup(value);

    debug_rhal_printf("\t\t\t--- VALUE ---\n\t\t\tCmd: %s, Value: %s\n", ptr->sid, ptr->value);
    return matrix;
}


/*
 * Description: Get the priority of the arg
 */
CLIMatrix graph_arg_insert_prio(char *prio) {
    CLIArgNode 	ptr = NULL;

    if (!matrix->arg) {
	TRS_ERR("Could not find argument!");
	parserr = 1;
	return matrix;
    }

    ptr = (CLIArgNode)matrix->arg->data;
    ptr->prio = strdup(prio);

    debug_rhal_printf("\t\t\t--- PRIORITY ---\n\t\t\tCmd: %s, Priority: %s\n", ptr->sid, ptr->prio);

    return matrix;
}


/*
 * Description: Get the parent arguments in case this arguments depends from another
 */
CLIMatrix graph_arg_insert_parent(char *parent) {
    CLICmdNode	cmd_node = NULL;
    SList	list = NULL;
    CLIArgNode 	arg_node = NULL,
		curr_node = NULL;
    char	*parent_s = NULL;

    if (!matrix->arg) {
	TRS_ERR("Could not find argument!");
	parserr = 1;
	return matrix;
    }

    cmd_node = (CLICmdNode)matrix->cmd->data;
    list = (SList)cmd_node->arg_list;
    curr_node = (CLIArgNode)matrix->arg->data;
    parent_s = strdup(parent);
    while (list) {
	arg_node = (CLIArgNode)list->data;
	/* If the 'arg sid' in the 'arg list' I'm passing is equal 
         * to the received 'arg name' and the current 'arg sid' to which 
         * the global 'arg ptr' points is different to the received 'arg name'
	 * then we can save the valid 'arg parent' */
	if (!strcmp(arg_node->sid, parent_s) && strcmp(curr_node->sid, parent_s)) {
	    curr_node->parent = arg_node->id;
	    break;
	}
	list = list->next;
    }

    if (curr_node->parent < 0) {
	TRS_ERR("Parent argument '%s' not found for child argument '%s'", 
            parent_s, curr_node->name);
	debug_rhal_printf("\t\t\t--- PARENT ---\n\t\t\tParent argument '%s' not found\n",
            parent_s);
    }
#ifdef DEBUG_RHAL
    else
	printf("\t\t\t--- PARENT ---\n\t\t\tArgument: %s, Parent id: %d\n",  
            curr_node->name, curr_node->parent);
#endif

    free(parent_s);
    return matrix;
}


/***********************
 * DESC functions
 ***********************/

/*
 * Description: Get the command or argument description
 */
CLIMatrix graph_insert_desc(char *desc) {
    CLICmdNode	cmd_node = NULL;
    CLIArgNode	arg_node = NULL;

    cmd_node = (CLICmdNode)matrix->cmd->data;
    if (cmd_node->arg_list == (SList)NULL) {
        if ((cmd_node->desc = (char *)xmalloc(sizeof(char), strlen(desc) - 1)) == NULL) {
            parserr = 1;
            return matrix;
        }
        reset_buff(cmd_node->desc, strlen(desc) - 1);
	/* Removed the unwanted " at the start and end of the 'desc' string */
        strncpy(cmd_node->desc, desc + 1, strlen(desc) - 2);
    }
    else {
	arg_node = (CLIArgNode)matrix->arg->data;
        if ((arg_node->desc = (char *)xmalloc(sizeof(char), strlen(desc) - 1)) == NULL) {
            parserr = 1;
            return matrix;
        }
        reset_buff(arg_node->desc, strlen(desc) - 1);
	/* Removed the unwanted " at the start and end of the 'desc' string */
        strncpy(arg_node->desc, desc + 1, strlen(desc) - 2);
    }

#ifdef DEBUG_RHAL
    if (cmd_node->arg_list == (SList)NULL)
	printf("\t\t--- DESC ---\n\t\tDesc: %s\n", cmd_node->desc);
    else
	printf("\t\t\t--- DESC ---\n\t\t\tDesc: %s\n", arg_node->desc);
#endif

    return matrix;
}

